use embassy_futures::select::{select3, Either3};
use embassy_net_driver_channel as ch;
use embassy_sync::pubsub::PubSubBehavior;
use embassy_time::{block_for, Duration, Timer};
use embedded_hal_1::digital::OutputPin;

use crate::bus::Bus;
pub use crate::bus::SpiBusCyw43;
use crate::consts::*;
use crate::events::{Event, Events, Status};
use crate::fmt::Bytes;
use crate::ioctl::{IoctlState, IoctlType, PendingIoctl};
use crate::nvram::NVRAM;
use crate::structs::*;
use crate::{events, slice8_mut, Core, CHIP, MTU};

#[cfg(feature = "firmware-logs")]
struct LogState {
    addr: u32,
    last_idx: usize,
    buf: [u8; 256],
    buf_count: usize,
}

#[cfg(feature = "firmware-logs")]
impl Default for LogState {
    fn default() -> Self {
        Self {
            addr: Default::default(),
            last_idx: Default::default(),
            buf: [0; 256],
            buf_count: Default::default(),
        }
    }
}

pub struct Runner<'a, PWR, SPI> {
    ch: ch::Runner<'a, MTU>,
    bus: Bus<PWR, SPI>,

    ioctl_state: &'a IoctlState,
    ioctl_id: u16,
    sdpcm_seq: u8,
    sdpcm_seq_max: u8,

    events: &'a Events,

    #[cfg(feature = "firmware-logs")]
    log: LogState,
}

struct DataEntry {
    address: u32,
    bytes: &'static [u8],
}

impl<'a, PWR, SPI> Runner<'a, PWR, SPI>
where
    PWR: OutputPin,
    SPI: SpiBusCyw43,
{
    pub(crate) fn new(
        ch: ch::Runner<'a, MTU>,
        bus: Bus<PWR, SPI>,
        ioctl_state: &'a IoctlState,
        events: &'a Events,
    ) -> Self {
        Self {
            ch,
            bus,
            ioctl_state,
            ioctl_id: 0,
            sdpcm_seq: 0,
            sdpcm_seq_max: 1,
            events,
            #[cfg(feature = "firmware-logs")]
            log: LogState::default(),
        }
    }

    pub(crate) async fn init(&mut self, firmware: &[u8]) {
        self.bus.init().await;

        // Init ALP (Active Low Power) clock
        self.bus
            .write8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR, BACKPLANE_ALP_AVAIL_REQ)
            .await;
        debug!("waiting for clock...");
        while self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR).await & BACKPLANE_ALP_AVAIL == 0 {}
        debug!("clock ok");

        let chip_id = self.bus.bp_read16(0x1800_0000).await;
        debug!("chip ID: {}", chip_id);

        // Upload firmware.
        self.core_disable(Core::WLAN).await;
        self.core_reset(Core::SOCSRAM).await;
        self.bus.bp_write32(CHIP.socsram_base_address + 0x10, 3).await;
        self.bus.bp_write32(CHIP.socsram_base_address + 0x44, 0).await;

        let ram_addr = CHIP.atcm_ram_base_address;

        debug!("loading fw");
        self.bus.bp_write(ram_addr, firmware).await;

        // bluetooth
        debug!("loading bluetooth fw");
        // cybt_reg_write(BTFW_MEM_OFFSET + BT2WLAN_PWRUP_ADDR, BT2WLAN_PWRUP_WAKE);
        self.bus.bp_write32(CHIP.btfw_base_address + BT2WLAN_PWRUP_ADDR, BT2WLAN_PWRUP_WAKE).await;
        // cybt_mem_write(fwmem_start_addr, p_mem_ptr, write_data_len);
        self.write_bluetooth_fimrware().await;
         // cybt_wait_bt_ready(BTSDIO_FW_READY_POLLING_RETRY_COUNT);
         loop {
            let val = self
                .bus
                .bp_read32(CHIP.pmu_base_address + REG_BACKPLANE_BT_CTRL_REG_ADDR)
                .await;
            info!("bluetooth_init: {:#x}", val);
            if val & BTSDIO_REG_BT_AWAKE_BITMASK != 0 {
                break;
            }
            Timer::after(Duration::from_millis(300)).await;
        }
        // cybt_init_buffer
        // TODO
        // cybt_wait_bt_awake(BTSDIO_FW_AWAKE_POLLING_RETRY_COUNT);
        // TODO
        while self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR).await & 0x80 == 0 {}
        self.bus
            .write16(FUNC_BUS, REG_BUS_INTERRUPT_ENABLE, IRQ_F2_PACKET_AVAILABLE | IRQ_F1_INTR)
            .await;

        debug!("loading nvram");
        // Round up to 4 bytes.
        let nvram_len = (NVRAM.len() + 3) / 4 * 4;
        self.bus
            .bp_write(ram_addr + CHIP.chip_ram_size - 4 - nvram_len as u32, NVRAM)
            .await;

        let nvram_len_words = nvram_len as u32 / 4;
        let nvram_len_magic = (!nvram_len_words << 16) | nvram_len_words;
        self.bus
            .bp_write32(ram_addr + CHIP.chip_ram_size - 4, nvram_len_magic)
            .await;

        // Start core!
        debug!("starting up core...");
        self.core_reset(Core::WLAN).await;
        assert!(self.core_is_up(Core::WLAN).await);

        // wifi
        //self.init_wifi().await;
    }

    pub(crate) async fn write_bluetooth_fimrware(&mut self) {
        // TODO: figure out how to parse the supplied C header as a mock .ihex or something?
        let bluetooth_firmware_lines = [
            DataEntry { address: 0x1921e000, bytes: &[0x42, 0x52, 0x43, 0x4d, 0x63, 0x66, 0x67, 0x53, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x01, 0x04, 0x18, 0x92, 0x00, 0x00, 0x00, 0x03, 0x06, 0xac, 0x1f, 0x12, 0xa2, 0x43, 0x43, 0x00, 0x01, 0x1c, 0x00, 0xf0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x1921f000, bytes: &[0x42, 0x52, 0x43, 0x4d, 0x63, 0x66, 0x67, 0x44, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x0b, 0x00, 0x00, 0x03, 0x03, 0x18, 0x53, 0x44, 0x49, 0x4f, 0x20, 0x33, 0x37, 0x5f, 0x34, 0x4d, 0x20, 0x77, 0x6c, 0x62, 0x67, 0x61, 0x5f, 0x42, 0x55, 0x20, 0x52, 0x50, 0x49, 0x00, 0x16, 0x03, 0x02, 0x00, 0x00, 0x02, 0x01, 0x90, 0x01, 0x08, 0x01, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x62, 0x08, 0x00, 0x00, 0x70, 0x00, 0x64, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xac, 0x00, 0x32, 0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x2f, 0x00, 0x64, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x6c, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x70, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x74, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x78, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x7c, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x84, 0x01, 0x60, 0x00, 0xff, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x04, 0x03, 0x0c, 0x20, 0x01, 0x20, 0x00, 0x0f, 0x14, 0x1a, 0x66, 0x0a, 0x15, 0x00, 0x00, 0x05, 0x03, 0x15, 0x00, 0x1b, 0x78, 0x50, 0xff, 0xff, 0x3f, 0x00, 0x05, 0x03, 0x1f, 0x64, 0xb0, 0xbd, 0x0a, 0x05, 0x00, 0xff, 0xff, 0x07, 0xbc, 0x09, 0x01, 0x04, 0x02, 0x0f, 0x00, 0x00, 0x22, 0x03, 0x02, 0x01, 0x00, 0xf0, 0x01, 0x28, 0x04, 0x00] },
            DataEntry { address: 0x1921f0f8, bytes: &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x01, 0x01, 0x06, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x28, 0x01, 0x00, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x05, 0x01, 0x06, 0x06, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x28, 0x02, 0x00, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x01, 0x01, 0x06, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf0, 0x01, 0xa0, 0x01, 0x03, 0x00, 0x00, 0x00, 0x10, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0x00, 0x14, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0x00, 0x18, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0x00, 0x1c, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x4c, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x05, 0x01, 0x06, 0x06, 0x24, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x34, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x38, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x15, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x06, 0x00, 0x00] },
            DataEntry { address: 0x1921f1f4, bytes: &[0x01, 0x00, 0x00, 0x00, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x64, 0x00, 0x51, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x78, 0x08, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0xb5, 0x03, 0x00, 0x06, 0x0a, 0x23, 0x3c, 0x5a, 0x6e, 0x7d, 0x05, 0x5c, 0x03, 0x3e, 0x03, 0x48, 0x03, 0x5c, 0x03, 0x48, 0x03, 0x98, 0x03, 0x7a, 0x03, 0x84, 0x03, 0x98, 0x03, 0x84, 0x03, 0xd4, 0x03, 0xb6, 0x03, 0xc0, 0x03, 0xd4, 0x03, 0xc0, 0x03, 0x1a, 0x04, 0xfc, 0x03, 0x06, 0x04, 0x1a, 0x04, 0x06, 0x04, 0x60, 0x04, 0x42, 0x04, 0x4c, 0x04, 0x60, 0x04, 0x4c, 0x04, 0xa6, 0x04, 0x88, 0x04, 0x92, 0x04, 0xa6, 0x04, 0x92, 0x04, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x44, 0x02, 0x30, 0x02, 0x26, 0x02, 0x12, 0x02, 0x1c, 0x02, 0x80, 0x02, 0x6c, 0x02, 0x62, 0x02, 0x4e, 0x02, 0x58, 0x02, 0xbc, 0x02, 0xa8, 0x02, 0x9e, 0x02, 0x8a, 0x02, 0x94, 0x02, 0x02, 0x03, 0xee, 0x02, 0xe4, 0x02, 0xd0, 0x02, 0xda, 0x02, 0x48, 0x03, 0x34, 0x03, 0x2a, 0x03, 0x16, 0x03, 0x20, 0x03, 0x8e, 0x03, 0x7a, 0x03, 0x70, 0x03, 0x5c, 0x03, 0x66, 0x03, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x06, 0x00, 0x00, 0x00, 0x60, 0x00, 0x05, 0x9c, 0x02, 0xff, 0xa0, 0x02, 0xff, 0xa4, 0x02, 0xff, 0xa8, 0x02, 0xff, 0xac, 0x02, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0xc8, 0x02, 0xff, 0xcc, 0x02, 0xff, 0xd0, 0x02, 0xff, 0xd4, 0x02, 0xff, 0xd8, 0x02, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x88, 0x03, 0xff, 0x8c, 0x03, 0xff, 0x90, 0x03, 0xff, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x1921f2f0, bytes: &[0x01, 0x94, 0x03, 0xff, 0x98, 0x03, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x9c, 0x03, 0xff, 0xa0, 0x03, 0xff, 0xa4, 0x03, 0xff, 0xa8, 0x03, 0xff, 0xac, 0x03, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x80, 0x03, 0xff, 0x84, 0x03, 0xff, 0xa0, 0x06, 0xff, 0xb4, 0x02, 0xff, 0x38, 0x07, 0xff, 0x00, 0x00, 0x60, 0x00, 0x03, 0xa4, 0x06, 0xff, 0x5c, 0x06, 0xff, 0x98, 0x06, 0xff, 0x45, 0x3d, 0x34, 0x2f, 0x2e, 0x38, 0x33, 0x2d, 0x2a, 0x27, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x18, 0x03, 0xfa, 0x65, 0x04, 0xcc, 0x4e, 0x4a, 0x3d, 0x39, 0x37, 0x40, 0x3a, 0x33, 0x2e, 0x2d, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1a, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x5f, 0x58, 0x4d, 0x47, 0x43, 0x4b, 0x45, 0x3d, 0x37, 0x35, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x6d, 0x6a, 0x59, 0x53, 0x52, 0x57, 0x51, 0x47, 0x40, 0x3e, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x80, 0x79, 0x68, 0x60, 0x5d, 0x61, 0x5a, 0x50, 0x48, 0x46, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x67, 0x04, 0xcc, 0x90, 0x8a, 0x78, 0x6f, 0x6b, 0x6f, 0x65, 0x59, 0x51, 0x4f, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x67, 0x24, 0xff, 0x01, 0x07, 0xb5, 0x03, 0x04, 0x06, 0x0a, 0x23, 0x3c, 0x5a, 0x6e, 0x7d, 0x05, 0x5c, 0x03, 0x3e, 0x03, 0x48, 0x03, 0x5c, 0x03, 0x48, 0x03] },
            DataEntry { address: 0x1921f3ec, bytes: &[0x98, 0x03, 0x7a, 0x03, 0x84, 0x03, 0x98, 0x03, 0x84, 0x03, 0xd4, 0x03, 0xb6, 0x03, 0xc0, 0x03, 0xd4, 0x03, 0xc0, 0x03, 0x1a, 0x04, 0xfc, 0x03, 0x06, 0x04, 0x1a, 0x04, 0x06, 0x04, 0x60, 0x04, 0x42, 0x04, 0x4c, 0x04, 0x60, 0x04, 0x4c, 0x04, 0xa6, 0x04, 0x88, 0x04, 0x92, 0x04, 0xa6, 0x04, 0x92, 0x04, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x44, 0x02, 0x30, 0x02, 0x26, 0x02, 0x12, 0x02, 0x1c, 0x02, 0x80, 0x02, 0x6c, 0x02, 0x62, 0x02, 0x4e, 0x02, 0x58, 0x02, 0xbc, 0x02, 0xa8, 0x02, 0x9e, 0x02, 0x8a, 0x02, 0x94, 0x02, 0x02, 0x03, 0xee, 0x02, 0xe4, 0x02, 0xd0, 0x02, 0xda, 0x02, 0x48, 0x03, 0x34, 0x03, 0x2a, 0x03, 0x16, 0x03, 0x20, 0x03, 0x8e, 0x03, 0x7a, 0x03, 0x70, 0x03, 0x5c, 0x03, 0x66, 0x03, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x06, 0x00, 0x00, 0x00, 0x60, 0x00, 0x05, 0x9c, 0x02, 0xff, 0xa0, 0x02, 0xff, 0xa4, 0x02, 0xff, 0xa8, 0x02, 0xff, 0xac, 0x02, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0xc8, 0x02, 0xff, 0xcc, 0x02, 0xff, 0xd0, 0x02, 0xff, 0xd4, 0x02, 0xff, 0xd8, 0x02, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x88, 0x03, 0xff, 0x8c, 0x03, 0xff, 0x90, 0x03, 0xff, 0x94, 0x03, 0xff, 0x98, 0x03, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x9c, 0x03, 0xff, 0xa0, 0x03, 0xff, 0xa4, 0x03, 0xff, 0xa8, 0x03, 0xff, 0xac, 0x03, 0xff, 0x00, 0x00, 0x60, 0x00, 0x05, 0x80, 0x03, 0xff, 0x84, 0x03, 0xff, 0xa0, 0x06, 0xff, 0xb4, 0x02, 0xff, 0x38, 0x07, 0xff, 0x00, 0x00, 0x60, 0x00, 0x03, 0xa4, 0x06, 0xff, 0x5c, 0x06, 0xff, 0x98, 0x06, 0xff, 0x45, 0x00] },
            DataEntry { address: 0x1921f4e4, bytes: &[0x01, 0x00, 0x00, 0x3d, 0x34, 0x2f, 0x2e, 0x38, 0x33, 0x2d, 0x2a, 0x27, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x18, 0x03, 0xfa, 0x65, 0x04, 0xcc, 0x4e, 0x4a, 0x3d, 0x39, 0x37, 0x40, 0x3a, 0x33, 0x2e, 0x2d, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1a, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x5f, 0x58, 0x4d, 0x47, 0x43, 0x4b, 0x45, 0x3d, 0x37, 0x35, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x6d, 0x6a, 0x59, 0x53, 0x52, 0x57, 0x51, 0x47, 0x40, 0x3e, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x66, 0x04, 0xcc, 0x80, 0x79, 0x68, 0x60, 0x5d, 0x61, 0x5a, 0x50, 0x48, 0x46, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x67, 0x04, 0xcc, 0x90, 0x8a, 0x78, 0x6f, 0x6b, 0x6f, 0x65, 0x59, 0x51, 0x4f, 0x88, 0x86, 0x86, 0x86, 0x85, 0xa8, 0xa6, 0xa6, 0xa6, 0xa4, 0xa4, 0xf4, 0x1f, 0x03, 0xfa, 0x67, 0x24, 0xff, 0x02, 0x07, 0x7f, 0x00, 0x06, 0x05, 0x5c, 0x03, 0x3e, 0x03, 0x48, 0x03, 0x5c, 0x03, 0x48, 0x03, 0x98, 0x03, 0x7a, 0x03, 0x84, 0x03, 0x98, 0x03, 0x84, 0x03, 0xd4, 0x03, 0xb6, 0x03, 0xc0, 0x03, 0xd4, 0x03, 0xc0, 0x03, 0x1a, 0x04, 0xfc, 0x03, 0x06, 0x04, 0x1a, 0x04, 0x06, 0x04, 0x60, 0x04, 0x42, 0x04, 0x4c, 0x04, 0x60, 0x04, 0x4c, 0x04, 0xa6, 0x04, 0x88, 0x04, 0x92, 0x04, 0xa6, 0x04, 0x92, 0x04, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x1921f5e0, bytes: &[0x01, 0x00, 0x05, 0x9c, 0x02, 0xff, 0xa0, 0x02, 0xff, 0xa4, 0x02, 0xff, 0xa8, 0x02, 0xff, 0xac, 0x02, 0xff, 0x45, 0x3d, 0x34, 0x2f, 0x2e, 0x4e, 0x4a, 0x3d, 0x39, 0x37, 0x5f, 0x58, 0x4d, 0x47, 0x43, 0x6d, 0x6a, 0x59, 0x53, 0x52, 0x80, 0x79, 0x68, 0x60, 0x5d, 0x90, 0x8a, 0x78, 0x6f, 0x6b, 0x02, 0x07, 0x7f, 0x04, 0x06, 0x05, 0x5c, 0x03, 0x3e, 0x03, 0x48, 0x03, 0x5c, 0x03, 0x48, 0x03, 0x98, 0x03, 0x7a, 0x03, 0x84, 0x03, 0x98, 0x03, 0x84, 0x03, 0xd4, 0x03, 0xb6, 0x03, 0xc0, 0x03, 0xd4, 0x03, 0xc0, 0x03, 0x1a, 0x04, 0xfc, 0x03, 0x06, 0x04, 0x1a, 0x04, 0x06, 0x04, 0x60, 0x04, 0x42, 0x04, 0x4c, 0x04, 0x60, 0x04, 0x4c, 0x04, 0xa6, 0x04, 0x88, 0x04, 0x92, 0x04, 0xa6, 0x04, 0x92, 0x04, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x14, 0xff, 0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x05, 0x9c, 0x02, 0xff, 0xa0, 0x02, 0xff, 0xa4, 0x02, 0xff, 0xa8, 0x02, 0xff, 0xac, 0x02, 0xff, 0x45, 0x3d, 0x34, 0x2f, 0x2e, 0x4e, 0x4a, 0x3d, 0x39, 0x37, 0x5f, 0x58, 0x4d, 0x47, 0x43, 0x6d, 0x6a, 0x59, 0x53, 0x52, 0x80, 0x79, 0x68, 0x60, 0x5d, 0x90, 0x8a, 0x78, 0x6f, 0x6b, 0x00, 0x07, 0x04, 0x3f, 0x00, 0x00, 0x00, 0x04, 0x07, 0x98, 0x01, 0x00, 0x32, 0x1f, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x1a, 0x02, 0x00, 0x17, 0x02, 0x00, 0x15, 0x12, 0x00, 0x13, 0x55, 0x00, 0x11, 0x64, 0x00, 0x0f, 0x11, 0x00, 0x0e, 0x03, 0x00, 0x0d, 0x14, 0x00, 0x0b, 0x50, 0x00, 0x0a, 0x64, 0x00, 0x09, 0x23, 0x00, 0x08, 0x23, 0x00, 0x07, 0x03, 0x00, 0x07, 0x16, 0x00, 0x06, 0x15, 0x00, 0x05, 0x13, 0x00, 0x05, 0x16, 0x00, 0x04, 0x13, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x1921f6dc, bytes: &[0x01, 0x00, 0x04, 0x26, 0x00, 0x04, 0x19, 0x00, 0x03, 0x05, 0x00, 0x03, 0x08, 0x00, 0x03, 0x2a, 0x00, 0x02, 0x03, 0x00, 0x02, 0x16, 0x00, 0x02, 0x09, 0x00, 0x02, 0x2b, 0x00, 0x02, 0x3d, 0x00, 0x02, 0x3f, 0x00, 0x01, 0x02, 0x00, 0x01, 0x15, 0x00, 0x01, 0x18, 0x00, 0x01, 0x3a, 0x00, 0x01, 0x1d, 0x00, 0x01, 0x1f, 0x00, 0x01, 0x8f, 0x00, 0x01, 0xef, 0x00, 0x01, 0x3f, 0x01, 0x01, 0x8f, 0x01, 0x01, 0xcf, 0x01, 0x01, 0x0f, 0x02, 0x01, 0x4f, 0x02, 0x01, 0x7f, 0x02, 0x01, 0xaf, 0x02, 0x01, 0xcf, 0x02, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x07, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x02, 0xfe, 0x0b, 0xe4, 0xfe, 0x1c, 0x01, 0xe4, 0xfe, 0x1c, 0x01, 0x0a, 0x02, 0xfe, 0x0b, 0xf1, 0xff, 0x0f, 0x00, 0xf1, 0xff, 0x0f, 0x00, 0x05, 0x07, 0x24, 0x00, 0x01, 0x08, 0x08, 0x0c, 0x00, 0x08, 0x01, 0x04, 0x02, 0x00, 0x03, 0xfc, 0x04, 0xf8, 0x05, 0xf4, 0x06, 0xf0, 0x07, 0x0c, 0x00, 0x08, 0x01, 0x04, 0x02, 0x00, 0x03, 0xfc, 0x04, 0xf8, 0x05, 0xf4, 0x06, 0xf0, 0x07, 0x0f, 0x03, 0x28, 0x02, 0x78, 0x14, 0x7f, 0x5a, 0x00, 0x14, 0x02, 0x14, 0x1e, 0x00, 0x02, 0x03, 0x00, 0x1e, 0xaa, 0x33, 0x19, 0x05, 0xcf, 0x00, 0x80, 0x0a, 0x92, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x08, 0xd0, 0x38, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x01, 0xb8, 0x01, 0xac, 0x9b, 0x20, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x01, 0x01, 0x06, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00] },
            DataEntry { address: 0x1921f7d8, bytes: &[0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x05, 0x01, 0x06, 0x06, 0xf8, 0x00, 0x64, 0x00, 0x51, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x78, 0x08, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x20, 0x15, 0x32, 0x00, 0xff, 0xff, 0xfa, 0xff, 0x01, 0x01, 0x06, 0x00, 0xf8, 0x00, 0x64, 0x00, 0x51, 0x00, 0x00, 0x00, 0xd3, 0x00, 0x00, 0x00, 0x78, 0x08, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x28, 0x15, 0x32, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x34, 0x10, 0x20, 0x02, 0x2c, 0x09, 0x64, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x07, 0x0a, 0x0d, 0x00, 0x07, 0x00, 0x0a, 0x00, 0x07, 0x0b, 0x0d, 0x00, 0x04, 0x00, 0x08, 0x00, 0x2b, 0x0b, 0x0d, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x01, 0x5c, 0xc4, 0x9c, 0x20, 0x00, 0x70, 0xb5, 0x00, 0x24, 0x12, 0x4d, 0x20, 0xe0, 0x12, 0x48, 0x02, 0x19, 0x11, 0x68, 0x21, 0xf0, 0x7f, 0x40, 0x09, 0x0e, 0x0a, 0xd0, 0x01, 0x29, 0x0b, 0xd0, 0x02, 0x29, 0x09, 0xd0, 0x03, 0x29, 0x0b, 0xd0, 0x04, 0x29, 0x09, 0xd0, 0x05, 0x29, 0x0b, 0xd0, 0x0d, 0xe0, 0x51, 0x68, 0x01, 0x60, 0x0a, 0xe0, 0x51, 0x68, 0xfa, 0xf5, 0xbb, 0xfe, 0x06, 0xe0, 0x51, 0x68, 0xfa, 0xf5, 0xcb, 0xfe, 0x02, 0xe0, 0x51, 0x68, 0xfa, 0xf5, 0xd1, 0xfe, 0x08, 0x34, 0xac, 0x42, 0xdc, 0xd3, 0x70, 0xbd, 0x98, 0x00] },
            DataEntry { address: 0x1921f8d0, bytes: &[0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x9d, 0x20, 0x00, 0x03, 0x01, 0x9c, 0x01, 0x1c, 0x9d, 0x20, 0x00, 0x14, 0x8d, 0x00, 0x04, 0x5b, 0x49, 0x1f, 0x22, 0xec, 0x12, 0x07, 0x02, 0x01, 0x02, 0x0d, 0x00, 0x79, 0x2d, 0x07, 0x01, 0xed, 0x03, 0x0d, 0x00, 0x8d, 0xb5, 0x04, 0x01, 0x19, 0x05, 0x0d, 0x00, 0xd5, 0x43, 0x04, 0x02, 0x11, 0x02, 0x0d, 0x00, 0x2d, 0x65, 0x04, 0x02, 0x19, 0x02, 0x0d, 0x00, 0xed, 0xa2, 0x04, 0x02, 0x35, 0x02, 0x0d, 0x00, 0xf1, 0x82, 0x06, 0x01, 0x1d, 0x06, 0x0d, 0x00, 0x95, 0x99, 0x06, 0x02, 0x49, 0x02, 0x0d, 0x00, 0xd1, 0x6e, 0x03, 0x02, 0x69, 0x02, 0x0d, 0x00, 0xe5, 0x75, 0x03, 0x02, 0x8b, 0x02, 0x0d, 0x00, 0x11, 0x5b, 0x02, 0x02, 0xa5, 0x02, 0x0d, 0x00, 0xb9, 0xe7, 0x00, 0x01, 0x81, 0x09, 0x0d, 0x00, 0x71, 0x20, 0x01, 0x01, 0xcd, 0x09, 0x0d, 0x00, 0xd5, 0x7f, 0x03, 0x02, 0xb9, 0x02, 0x0d, 0x00, 0x19, 0x19, 0x05, 0x01, 0x11, 0x0c, 0x0d, 0x00, 0xb1, 0xb4, 0x00, 0x02, 0xc5, 0x02, 0x0d, 0x00, 0xb5, 0xfc, 0x05, 0x02, 0xcd, 0x02, 0x0d, 0x00, 0xb9, 0x2f, 0x00, 0x02, 0xd9, 0x02, 0x0d, 0x00, 0x33, 0x01, 0x28, 0xec, 0x05, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0xf0, 0x51, 0x27, 0x79, 0x05, 0xf3, 0xad, 0xc9, 0x9e, 0x95, 0x21, 0x49, 0x46, 0x91, 0xf1, 0x4b, 0x0c, 0xf3, 0x81, 0x88, 0xb3, 0x4a, 0x37, 0xf3, 0x7a, 0xae, 0xba, 0x58, 0xe0, 0xd0, 0xe0, 0x37, 0x33, 0x01, 0x28, 0xd8, 0x09, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x75, 0xa0, 0xe4, 0xf5, 0xa2, 0x38, 0x0e, 0x0e, 0xa1, 0x0c, 0x4e, 0x46, 0x3a, 0x2a, 0x1a, 0x33, 0xfa, 0xa6, 0x79, 0x72, 0xe5, 0xf4, 0xd1, 0xf3, 0xe3, 0xe1, 0xfb, 0x91, 0x9f, 0x12, 0x00, 0x00] },
            DataEntry { address: 0x1921f9cc, bytes: &[0x01, 0x00, 0x0f, 0x34, 0x33, 0x01, 0x28, 0xd4, 0x38, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x39, 0x5b, 0xd0, 0x9e, 0xa6, 0xbc, 0x73, 0x55, 0x7c, 0x30, 0xf3, 0xe0, 0x4f, 0x2c, 0x82, 0xca, 0x5e, 0x7b, 0xdf, 0xc7, 0x3e, 0x23, 0xec, 0xb1, 0xd2, 0x18, 0xe7, 0xf6, 0x80, 0x0f, 0x1b, 0xbb, 0x33, 0x01, 0x28, 0xe7, 0x06, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x92, 0x75, 0x5a, 0xa1, 0x29, 0xac, 0x61, 0xb5, 0x71, 0x8e, 0x3f, 0xf3, 0xb0, 0xd6, 0x11, 0x3e, 0x7d, 0xf6, 0x87, 0x34, 0xc4, 0x0a, 0xa3, 0x31, 0x2d, 0x72, 0x8f, 0xb9, 0x45, 0xaf, 0x8c, 0xab, 0x33, 0x01, 0x28, 0xf1, 0x04, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0xd8, 0xf9, 0x29, 0x36, 0x16, 0xeb, 0x48, 0x9d, 0x58, 0x51, 0xce, 0xbd, 0x2b, 0x42, 0x74, 0x02, 0xfe, 0x62, 0x7d, 0xfe, 0x04, 0x46, 0x8d, 0x7c, 0x59, 0x9b, 0xd5, 0xbc, 0x35, 0x5b, 0x0b, 0x0a, 0x33, 0x01, 0x28, 0xdd, 0x08, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x7f, 0xbf, 0xbe, 0xe3, 0x5c, 0x8f, 0xd5, 0x66, 0xa2, 0x17, 0x80, 0xa4, 0x35, 0x1a, 0x04, 0xb2, 0x80, 0xbd, 0xda, 0x72, 0x5e, 0xff, 0x68, 0x68, 0xd7, 0x45, 0xf3, 0x14, 0xf4, 0x0d, 0x7b, 0xab, 0x33, 0x01, 0x28, 0xfb, 0x02, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x96, 0x0b, 0xfc, 0x2b, 0xc2, 0xaf, 0x3b, 0xa0, 0x85, 0x51, 0x68, 0xfc, 0xb1, 0xc2, 0x11, 0x29, 0x0a, 0xd5, 0x8d, 0x3b, 0xb2, 0x97, 0x3e, 0xc5, 0x06, 0x3f, 0xc6, 0xc1, 0xb0, 0xd4, 0xae, 0x2b, 0x33, 0x01, 0x28, 0xf6, 0x03, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x32, 0xf8, 0xe5, 0x50, 0x49, 0x57, 0xf7, 0x31, 0x4a, 0x66, 0x06, 0xf5, 0x93, 0x29, 0x96, 0x5e, 0x3e, 0x63, 0x1f, 0x49, 0xe3, 0x00, 0xe0, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x1921fac8, bytes: &[0x01, 0x14, 0xfd, 0xe6, 0x75, 0xf2, 0x60, 0x73, 0x15, 0xa7, 0x33, 0x01, 0x28, 0xc9, 0x0c, 0x0d, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x54, 0xe1, 0x87, 0x64, 0x1b, 0x57, 0xae, 0x79, 0x2a, 0x8b, 0x78, 0x49, 0x11, 0xea, 0x5a, 0x65, 0x22, 0x77, 0xcd, 0xd1, 0xf8, 0xc9, 0x26, 0x89, 0xa6, 0x72, 0x47, 0x97, 0xbc, 0x01, 0x3a, 0x84, 0x33, 0x01, 0x28, 0xd3, 0x0a, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x25, 0xd5, 0xcc, 0x2e, 0x8c, 0x15, 0x52, 0x18, 0xd9, 0x28, 0x48, 0xc4, 0x7c, 0x13, 0x37, 0xc9, 0xce, 0xb9, 0x48, 0xce, 0xa1, 0x13, 0x91, 0xb8, 0x2c, 0x48, 0xf4, 0x3f, 0x1c, 0xa5, 0xc7, 0x6a, 0x33, 0x01, 0x28, 0xe2, 0x07, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0xd2, 0x1f, 0xc7, 0xc1, 0xc8, 0xb0, 0xec, 0x89, 0x53, 0xf4, 0x00, 0xb0, 0x2d, 0xb3, 0xde, 0x20, 0xec, 0x00, 0xb0, 0x5d, 0x31, 0x2d, 0xf2, 0x44, 0x60, 0x60, 0xbc, 0xb9, 0xcc, 0x56, 0x28, 0xda, 0x33, 0x01, 0x28, 0xce, 0x0b, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0x55, 0xd8, 0x9d, 0x78, 0x0d, 0x01, 0xf7, 0xb8, 0x06, 0x17, 0xfb, 0x48, 0x10, 0x73, 0x1d, 0x3c, 0x11, 0x4e, 0xca, 0x7c, 0x1b, 0xf2, 0x6e, 0x7b, 0x19, 0xd2, 0xac, 0x2b, 0x82, 0x6e, 0xdf, 0xdb, 0x33, 0x01, 0x28, 0x00, 0x02, 0x0d, 0x00, 0xfb, 0x00, 0x00, 0x00, 0xdb, 0xf7, 0xd4, 0x05, 0xa2, 0x6d, 0xbb, 0xe6, 0x77, 0x99, 0xe8, 0x3c, 0x47, 0x5d, 0xa0, 0x92, 0xec, 0x5c, 0x79, 0x14, 0xc9, 0x00, 0x63, 0x39, 0x0f, 0x7d, 0xce, 0x70, 0xe6, 0x72, 0xae, 0x32, 0x33, 0x01, 0x28, 0x64, 0x41, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7e, 0x38, 0x53, 0x55, 0x65, 0x0e, 0x34, 0x52, 0x01, 0x7e, 0x2a, 0x8e, 0xe6, 0x00, 0x92, 0x2f] },
            DataEntry { address: 0x1921fbc4, bytes: &[0x38, 0xde, 0x3a, 0xbc, 0x00, 0x96, 0xc7, 0x41, 0x4a, 0x04, 0x81, 0x57, 0x9a, 0x22, 0xa5, 0xee, 0x06, 0x01, 0x04, 0x21, 0x03, 0x0d, 0x00, 0x13, 0x01, 0x01, 0x09, 0xfe, 0x00, 0x00, 0x91, 0xa9, 0x9e, 0xe2, 0xeb, 0x29, 0x32, 0xb3, 0xeb, 0x6d, 0x6e, 0x60, 0x43, 0x73, 0xd1, 0xa8, 0x43, 0xda, 0x86, 0x44, 0x03, 0x3e, 0x85, 0x4a, 0x6f, 0xbf, 0x8c, 0x0e, 0xcf, 0xbc, 0x23, 0xe5, 0xb7, 0x93, 0xbe, 0x83, 0x4f, 0x7b, 0xd9, 0x81, 0x65, 0x74, 0xdc, 0xfa, 0x97, 0x51, 0x30, 0x45, 0x91, 0xde, 0xc2, 0xee, 0xd2, 0x0f, 0xd0, 0xfe, 0x98, 0x74, 0xe9, 0xaf, 0x85, 0x69, 0xce, 0x0c, 0x00, 0x00] },
            DataEntry { address: 0x190d0200, bytes: &[0x4a, 0xf7, 0xf1, 0xff, 0x20, 0x46, 0x00, 0xf0, 0xdf, 0xf8, 0xa1, 0xf7, 0x67, 0xb8, 0x00, 0x00, 0xbd, 0xe8, 0x10, 0x40, 0x00, 0xf0, 0xa2, 0xb9, 0x10, 0x28, 0x09, 0xd8, 0x04, 0xf1, 0x0c, 0x00, 0x00, 0xf0, 0xe4, 0xf9, 0x20, 0xb1, 0x94, 0xf8, 0xe0, 0x00, 0x01, 0x21, 0x76, 0xf7, 0x86, 0xb9, 0x76, 0xf7, 0x7e, 0xb9, 0xc0, 0xb2, 0x8d, 0xf8, 0x03, 0x01, 0x25, 0x28, 0x3a, 0xf6, 0x82, 0xa0, 0x0a, 0x30, 0x7a, 0xf7, 0x57, 0xb8, 0x00, 0x00, 0x08, 0xd0, 0x20, 0x46, 0x00, 0xf0, 0x0e, 0xfb, 0x00, 0x28, 0x05, 0xd0, 0x03, 0x4d, 0x00, 0xbf, 0x99, 0xf7, 0x9e, 0xbb, 0x99, 0xf7, 0xea, 0xbb, 0x99, 0xf7, 0xe3, 0xbb, 0xb8, 0x58, 0x20, 0x00, 0x81, 0x43, 0x0a, 0xd1, 0x03, 0xb4, 0x30, 0x46, 0x49, 0x46, 0x22, 0x46, 0x00, 0xf0, 0x0a, 0xfb, 0x00, 0x28, 0x03, 0xbc, 0x03, 0xd0, 0x66, 0xf7, 0x98, 0xbe, 0x66, 0xf7, 0x27, 0xbe, 0x66, 0xf7, 0x83, 0xbe, 0x28, 0x46, 0x31, 0x46, 0x00, 0xf0, 0x1e, 0xfb, 0x18, 0xb1, 0x02, 0x48, 0xc0, 0x7c, 0x67, 0xf7, 0xa6, 0xb9, 0x67, 0xf7, 0xb7, 0xb9, 0x60, 0x44, 0x20, 0x00, 0x34, 0xb1, 0x00, 0xf0, 0x43, 0xfb, 0x18, 0xb1, 0x97, 0xf8, 0xcb, 0x10, 0x55, 0xf7, 0x31, 0xbc, 0x55, 0xf7, 0x35, 0xbc, 0x00, 0x20, 0x02, 0x90, 0xa8, 0x68, 0x00, 0x90, 0x67, 0xf7, 0x8a, 0xbe, 0xbd, 0xe8, 0x70, 0x40, 0x00, 0xf0, 0xbc, 0xbc, 0x06, 0x46, 0xe8, 0x19, 0x14, 0xf1, 0x08, 0x02, 0x8f, 0xf7, 0xf1, 0xbc, 0x08, 0x60, 0x00, 0xf0, 0xf5, 0xfc, 0xbd, 0xe8, 0x10, 0x40, 0x35, 0xf7, 0x8b, 0xbb, 0x00, 0x00, 0x01, 0x28, 0x02, 0xd0, 0x04, 0x28, 0x12, 0xd0, 0x14, 0xe0, 0x15, 0x48, 0x13, 0x49, 0x00, 0x68, 0x40, 0xf8, 0x0c, 0x00] },
            DataEntry { address: 0x190d02f8, bytes: &[0x01, 0x00, 0x00, 0x1f, 0x24, 0x31, 0x41, 0x60, 0x3c, 0x31, 0x81, 0x60, 0x09, 0x21, 0x01, 0x75, 0x0f, 0x21, 0x41, 0x75, 0x81, 0x75, 0x41, 0xf2, 0x88, 0x30, 0x0e, 0x49, 0x01, 0xe0, 0x0e, 0x48, 0x0e, 0x49, 0x08, 0x60, 0x00, 0x20, 0x70, 0x47, 0x10, 0xb5, 0x0d, 0x48, 0x0d, 0x49, 0xb1, 0xf7, 0x20, 0xff, 0x0e, 0x49, 0x0c, 0x48, 0x08, 0x60, 0x39, 0xf1, 0xc8, 0xfc, 0xaf, 0xf2, 0x4f, 0x00, 0x0b, 0x49, 0x08, 0x60, 0x0b, 0x49, 0x0a, 0x20, 0x08, 0x70, 0x10, 0xbd, 0xac, 0x9b, 0x20, 0x00, 0x20, 0x22, 0x20, 0x00, 0x48, 0x1f, 0x20, 0x00, 0x71, 0x03, 0x0d, 0x00, 0x34, 0x3a, 0x20, 0x00, 0x60, 0x9c, 0x20, 0x00, 0x64, 0x00, 0x00, 0x00, 0xb4, 0x9d, 0x20, 0x00, 0x64, 0x05, 0x20, 0x00, 0x94, 0x3c, 0x20, 0x00, 0x25, 0x2b, 0x20, 0x00, 0x30, 0xb4, 0x00, 0x24, 0x0c, 0x60, 0x05, 0x2b, 0x1e, 0xdd, 0x06, 0x2b, 0x1c, 0xd0, 0x08, 0x2b, 0x1a, 0xd0, 0x3f, 0x2b, 0x18, 0xd1, 0x0f, 0x4c, 0x19, 0x2a, 0x06, 0xd0, 0x1a, 0x2a, 0x08, 0xd0, 0xa2, 0xf5, 0x80, 0x75, 0x8b, 0x3d, 0x0f, 0xd1, 0x07, 0xe0, 0x25, 0x68, 0x0d, 0x60, 0x64, 0x68, 0x06, 0xe0, 0xa5, 0x68, 0x0d, 0x60, 0xe4, 0x68, 0x02, 0xe0, 0x25, 0x69, 0x0d, 0x60, 0x64, 0x69, 0x4c, 0x60, 0x0c, 0x68, 0x00, 0x2c, 0x02, 0xd1, 0x30, 0xbc, 0x9c, 0xf7, 0x64, 0xbe, 0x30, 0xbc, 0x70, 0x47, 0x00, 0x00, 0x48, 0x9c, 0x20, 0x00, 0x38, 0xb5, 0x04, 0x46, 0xc0, 0x69, 0x00, 0x22, 0x41, 0x79, 0x00, 0x79, 0x74, 0xf7, 0x7f, 0xf8, 0x00, 0x21, 0x00, 0x91, 0xe1, 0x69, 0x00, 0x23, 0x0a, 0x68, 0x01, 0x46, 0x18, 0x46, 0x74, 0xf7, 0x74, 0xfd, 0x38, 0xbd, 0x2d, 0xe9, 0xf0, 0x41, 0x06, 0x46, 0x7d, 0xf7, 0xf0, 0xfa, 0x00, 0x00] },
            DataEntry { address: 0x190d03f4, bytes: &[0x01, 0x00, 0x04, 0x00, 0x7d, 0xd0, 0x94, 0xf8, 0x3c, 0x00, 0xc0, 0x07, 0x7e, 0xd0, 0x40, 0x48, 0x00, 0x68, 0x80, 0x02, 0x1a, 0xd5, 0x04, 0xf1, 0x5c, 0x00, 0x94, 0xf8, 0x62, 0x10, 0x00, 0x22, 0x05, 0x46, 0xa6, 0xf7, 0x9d, 0xf8, 0xff, 0x28, 0x03, 0xd0, 0x00, 0x21, 0xa6, 0xf7, 0x72, 0xf8, 0x0c, 0xe0, 0x94, 0xf8, 0x62, 0x10, 0x28, 0x46, 0x74, 0xf7, 0x45, 0xfa, 0x30, 0xb1, 0x28, 0x46, 0x80, 0xf7, 0x8d, 0xfa, 0x10, 0xb1, 0xc0, 0x79, 0xff, 0x28, 0xee, 0xd1, 0x94, 0xf8, 0x62, 0x10, 0x22, 0x46, 0x04, 0xf1, 0x5c, 0x00, 0x7d, 0xf7, 0x0d, 0xfb, 0x05, 0x00, 0x0e, 0xd0, 0x68, 0x8f, 0x60, 0xb1, 0x34, 0xf7, 0xca, 0xf8, 0x07, 0x46, 0x15, 0xf8, 0xe2, 0x0f, 0x78, 0xf7, 0x37, 0xfb, 0x38, 0x46, 0x34, 0xf7, 0xc6, 0xf8, 0x28, 0x78, 0xa2, 0xf7, 0xa2, 0xfb, 0x30, 0x46, 0x7d, 0xf7, 0xd0, 0xfc, 0x30, 0x46, 0xa1, 0xf7, 0x31, 0xfa, 0x01, 0x20, 0x60, 0x87, 0x21, 0x48, 0x00, 0x78, 0x28, 0xb1, 0x4f, 0xf4, 0x46, 0x10, 0xc1, 0x69, 0x41, 0xf0, 0x80, 0x51, 0xc1, 0x61, 0x20, 0x46, 0x76, 0xf7, 0xf7, 0xfe, 0x1c, 0x48, 0x44, 0xf2, 0x10, 0x01, 0x00, 0x68, 0x08, 0x42, 0x26, 0xd1, 0x94, 0xf8, 0xe1, 0x00, 0x38, 0xb1, 0x30, 0x46, 0x7b, 0xf7, 0x29, 0xf9, 0x38, 0xb1, 0x00, 0x21, 0x7b, 0xf7, 0xd9, 0xf9, 0x07, 0xe0, 0x00, 0x20, 0xa2, 0xf7, 0x28, 0xfe, 0x03, 0xe0, 0x20, 0x21, 0x04, 0x20, 0x3f, 0xf7, 0x5a, 0xfe, 0x00, 0x21, 0x30, 0x46, 0xa2, 0xf7, 0xf4, 0xf8, 0x94, 0xf8, 0xe1, 0x00, 0x01, 0x28, 0x0b, 0xd1, 0x0d, 0x48, 0x00, 0x78, 0x01, 0x28, 0x07, 0xd1, 0x0c, 0x48, 0x00, 0x78, 0x01, 0x28, 0x03, 0xd1, 0x00, 0x21, 0x30, 0x46, 0x72, 0xf7, 0xb2, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x190d04f0, bytes: &[0x01, 0xf9, 0x20, 0x46, 0x00, 0xe0, 0x03, 0xe0, 0xbd, 0xe8, 0xf0, 0x41, 0xa2, 0xf7, 0x38, 0xbb, 0xbd, 0xe8, 0xf0, 0x81, 0xfc, 0x2f, 0x20, 0x00, 0x9f, 0x2f, 0x20, 0x00, 0x48, 0x31, 0x20, 0x00, 0x2c, 0x30, 0x20, 0x00, 0x34, 0x30, 0x20, 0x00, 0x10, 0xb5, 0x0f, 0x4c, 0x20, 0x68, 0x7b, 0xf7, 0x33, 0xf8, 0x02, 0x28, 0x11, 0xd0, 0x20, 0x68, 0x7b, 0xf7, 0x2e, 0xf8, 0x03, 0x28, 0x0c, 0xd0, 0x00, 0x20, 0x21, 0x68, 0x48, 0x61, 0x4f, 0xf4, 0x46, 0x10, 0xc1, 0x69, 0x21, 0xf0, 0x80, 0x51, 0xc1, 0x61, 0xbd, 0xe8, 0x10, 0x40, 0x75, 0xf7, 0x6a, 0xba, 0x21, 0x68, 0x88, 0x7b, 0x08, 0x31, 0x80, 0xf7, 0x3c, 0xfa, 0xed, 0xe7, 0x00, 0x00, 0x30, 0x30, 0x20, 0x00, 0x10, 0xb5, 0x3a, 0xf7, 0xa6, 0xff, 0x1d, 0x48, 0x4f, 0xf4, 0x46, 0x14, 0x00, 0x68, 0xc4, 0xf8, 0xa0, 0x00, 0x1b, 0x48, 0x00, 0x68, 0xc4, 0xf8, 0x94, 0x03, 0x1a, 0x48, 0x1a, 0x49, 0x00, 0x68, 0x08, 0x60, 0x09, 0x1f, 0x40, 0xf2, 0xad, 0x20, 0x08, 0x60, 0xe0, 0x69, 0x40, 0xf4, 0x00, 0x40, 0xe0, 0x61, 0xe0, 0x69, 0x20, 0xf0, 0x80, 0x50, 0xe0, 0x61, 0xe0, 0x69, 0x20, 0xf0, 0x01, 0x00, 0xe0, 0x61, 0x11, 0x49, 0x11, 0x48, 0x09, 0x1d, 0x08, 0x60, 0x9f, 0xf7, 0x0b, 0xfc, 0xa0, 0xf7, 0x39, 0xfd, 0x75, 0xf7, 0xfd, 0xfa, 0x9e, 0xf7, 0x45, 0xfe, 0x76, 0xf7, 0x34, 0xfd, 0xd4, 0xf8, 0x40, 0x03, 0x40, 0xf0, 0x20, 0x00, 0xc4, 0xf8, 0x40, 0x03, 0xa0, 0xf7, 0x0b, 0xfe, 0x76, 0xf7, 0x33, 0xfc, 0xbd, 0xe8, 0x10, 0x40, 0x3a, 0xf7, 0x04, 0xbe, 0x00, 0x00, 0xec, 0x35, 0x20, 0x00, 0xf0, 0x35, 0x20, 0x00, 0x04, 0x1f, 0x20, 0x00, 0xc0, 0x8b, 0x31, 0x00, 0x10, 0x32, 0x54, 0x76] },
            DataEntry { address: 0x190d05ec, bytes: &[0x7c, 0xb5, 0x01, 0x68, 0x00, 0x91, 0x00, 0x79, 0x00, 0x25, 0x20, 0xf0, 0xe0, 0x00, 0x8d, 0xf8, 0x04, 0x00, 0x2c, 0x46, 0x6e, 0x46, 0x30, 0x5d, 0x46, 0xf7, 0x59, 0xfd, 0x05, 0x44, 0x02, 0x2d, 0x01, 0xd3, 0x01, 0x20, 0x7c, 0xbd, 0x64, 0x1c, 0x05, 0x2c, 0xf4, 0xd3, 0x00, 0x20, 0x7c, 0xbd, 0x2d, 0xe9, 0xf0, 0x5f, 0x04, 0x46, 0x4f, 0xf0, 0x00, 0x0b, 0x97, 0xf7, 0x88, 0xfa, 0x50, 0xb1, 0x17, 0x21, 0x20, 0x46, 0x93, 0xf7, 0x38, 0xf8, 0x20, 0x46, 0xbd, 0xe8, 0xf0, 0x5f, 0x02, 0x22, 0x00, 0x21, 0x58, 0xf7, 0x66, 0xbf, 0x20, 0x46, 0x3f, 0xf7, 0xee, 0xfb, 0x09, 0x26, 0x8f, 0x4d, 0x00, 0x28, 0x7d, 0xd0, 0x69, 0x68, 0xa0, 0x8b, 0x0a, 0x7b, 0xc0, 0xf3, 0xc0, 0x30, 0x02, 0xf0, 0x01, 0x02, 0x90, 0x42, 0x07, 0xd0, 0x94, 0xf8, 0xa5, 0x00, 0x09, 0x28, 0x03, 0xd1, 0x94, 0xf8, 0xa3, 0x00, 0xc0, 0x07, 0x66, 0xd0, 0x10, 0x22, 0x04, 0xf5, 0x80, 0x70, 0x0d, 0x31, 0xb1, 0xf7, 0x78, 0xfc, 0x94, 0xf8, 0xa5, 0x00, 0x1a, 0x27, 0x4f, 0xf0, 0x1d, 0x08, 0x1c, 0x28, 0x11, 0xd0, 0x94, 0xf8, 0xa4, 0x00, 0x4f, 0xf0, 0x17, 0x0a, 0x4f, 0xf0, 0x18, 0x09, 0x98, 0xb1, 0x02, 0x28, 0x0c, 0xd0, 0x01, 0x28, 0x0f, 0xd0, 0x05, 0x28, 0x08, 0xd0, 0x06, 0x28, 0x06, 0xd0, 0x1b, 0x28, 0x38, 0xd0, 0xb4, 0xe0, 0x20, 0x68, 0x58, 0xf7, 0xf6, 0xfb, 0x0a, 0xe0, 0x68, 0x68, 0x00, 0x7b, 0x00, 0xf0, 0x01, 0x02, 0x95, 0xe0, 0x94, 0xf8, 0xa3, 0x10, 0xc9, 0x07, 0x0e, 0xd0, 0x1b, 0x28, 0x14, 0xd0, 0x68, 0x68, 0x00, 0x7b, 0x00, 0xf0, 0x01, 0x01, 0x20, 0x46, 0x97, 0xf7, 0x02, 0xfa, 0xa0, 0x8b, 0x00, 0x04, 0x1b, 0xd4, 0x84, 0xf8, 0xa5, 0x70, 0x98, 0x00] },
            DataEntry { address: 0x190d06e4, bytes: &[0x01, 0x00, 0x00, 0xe0, 0x01, 0x28, 0x02, 0xd0, 0x20, 0x46, 0x71, 0xf7, 0x40, 0xf9, 0x84, 0xf8, 0xa5, 0x60, 0x90, 0xe0, 0xa0, 0x8b, 0x00, 0x04, 0x0a, 0xd5, 0x68, 0x68, 0x00, 0x21, 0x00, 0x7b, 0x00, 0xf0, 0x01, 0x02, 0x20, 0x46, 0x97, 0xf7, 0xc7, 0xfa, 0x84, 0xf8, 0xa4, 0xa0, 0x82, 0xe0, 0x84, 0xf8, 0xa4, 0x90, 0x7f, 0xe0, 0x84, 0xf8, 0xa5, 0x80, 0x7c, 0xe0, 0x20, 0x68, 0x58, 0xf7, 0xbe, 0xfb, 0xa0, 0x8b, 0x00, 0x04, 0x0c, 0xd5, 0x68, 0x68, 0x00, 0x21, 0x00, 0x7b, 0x00, 0xf0, 0x01, 0x02, 0x20, 0x46, 0x97, 0xf7, 0xb0, 0xfa, 0x84, 0xf8, 0xa4, 0xa0, 0xbd, 0xe8, 0xf0, 0x9f, 0x02, 0xe0, 0x84, 0xf8, 0xa4, 0x90, 0xf9, 0xe7, 0x69, 0x68, 0xe3, 0x69, 0x04, 0xf1, 0x78, 0x07, 0x0a, 0x7b, 0xc3, 0xf3, 0xc0, 0x30, 0x02, 0xf0, 0x01, 0x02, 0x90, 0x42, 0x0b, 0xd0, 0x94, 0xf8, 0xa4, 0x00, 0x01, 0x28, 0x03, 0xd1, 0x94, 0xf8, 0xa3, 0x00, 0xc0, 0x07, 0x08, 0xd0, 0x94, 0xf8, 0xa5, 0x00, 0x09, 0x28, 0x0c, 0xd0, 0x94, 0xf8, 0xa5, 0x00, 0x0c, 0x28, 0x1e, 0xd0, 0x0b, 0xe0, 0x10, 0x22, 0x38, 0x46, 0x0d, 0x31, 0xb1, 0xf7, 0xf0, 0xfb, 0x84, 0xf8, 0xa5, 0x60, 0xd5, 0xe7, 0x94, 0xf8, 0xa3, 0x00, 0xc0, 0x07, 0xd1, 0xd0, 0x94, 0xf8, 0xa4, 0x00, 0x60, 0xb3, 0x02, 0x28, 0x23, 0xd0, 0x01, 0x28, 0x28, 0xd0, 0x04, 0x28, 0x26, 0xd0, 0x03, 0x28, 0x24, 0xd0, 0x05, 0x28, 0x1b, 0xd0, 0x06, 0x28, 0x19, 0xd0, 0x07, 0x28, 0x49, 0xd0, 0x2c, 0xe0, 0x20, 0x68, 0x58, 0xf7, 0x6e, 0xfb, 0xa0, 0x8b, 0x69, 0x68, 0x40, 0xf3, 0xc0, 0x32, 0x20, 0x46, 0x0d, 0x31, 0x52, 0x1c, 0x97, 0xf7, 0x62, 0xfa, 0xa0, 0x8b, 0x40, 0xf3, 0xc0, 0x31, 0x20, 0x46, 0x49, 0x1c, 0x00, 0x00] },
            DataEntry { address: 0x190d07e0, bytes: &[0x01, 0x00, 0x97, 0xf7, 0x7d, 0xf9, 0x0d, 0x20, 0x84, 0xf8, 0xa5, 0x00, 0x15, 0xe0, 0x20, 0x46, 0xbd, 0xe8, 0xf0, 0x5f, 0x06, 0x23, 0x0b, 0x21, 0x56, 0xf7, 0x89, 0xba, 0x94, 0xf8, 0xa3, 0x20, 0xd2, 0x07, 0x1a, 0xd0, 0x43, 0xf3, 0xc0, 0x32, 0x20, 0x46, 0x0d, 0x31, 0x52, 0x1c, 0x97, 0xf7, 0x45, 0xfa, 0x00, 0x21, 0x20, 0x46, 0x97, 0xf7, 0xf4, 0xf9, 0x69, 0x68, 0xa0, 0x8b, 0x09, 0x7b, 0xc0, 0xf3, 0xc0, 0x30, 0x01, 0xf0, 0x01, 0x01, 0x48, 0x40, 0x80, 0xf0, 0x01, 0x02, 0x59, 0x46, 0x20, 0x46, 0xbd, 0xe8, 0xf0, 0x5f, 0x97, 0xf7, 0x0b, 0xb9, 0x01, 0x28, 0x02, 0xd0, 0x20, 0x46, 0x71, 0xf7, 0x97, 0xf8, 0x69, 0x68, 0x10, 0x22, 0x38, 0x46, 0x0d, 0x31, 0xb1, 0xf7, 0x8f, 0xfb, 0x4f, 0xe7, 0x20, 0x68, 0x58, 0xf7, 0x25, 0xfb, 0xa0, 0x8b, 0x69, 0x68, 0xc0, 0xf3, 0xc0, 0x32, 0x20, 0x46, 0xbd, 0xe8, 0xf0, 0x5f, 0x0d, 0x31, 0x97, 0xf7, 0x18, 0xba, 0x10, 0xb5, 0x90, 0xf8, 0x57, 0x10, 0x4a, 0x07, 0x01, 0xd5, 0x09, 0x07, 0x03, 0xd4, 0x00, 0xf0, 0x71, 0xf8, 0x00, 0x20, 0x10, 0xbd, 0x01, 0x20, 0x10, 0xbd, 0x00, 0x00, 0xb8, 0x58, 0x20, 0x00, 0x30, 0xb5, 0x11, 0xf8, 0x04, 0x4f, 0x00, 0x23, 0x7f, 0x25, 0xb5, 0xeb, 0x54, 0x0f, 0x02, 0xd1, 0x49, 0x78, 0x01, 0x23, 0x00, 0xe0, 0x61, 0x08, 0x12, 0x78, 0x00, 0x7f, 0x02, 0xf0, 0x07, 0x04, 0x00, 0xf0, 0x07, 0x00, 0x84, 0x42, 0x03, 0xd1, 0x05, 0x29, 0x08, 0xd1, 0x3b, 0xb1, 0x02, 0xe0, 0x1b, 0xb1, 0x05, 0x29, 0x01, 0xd1, 0x50, 0x07, 0x01, 0xd0, 0x01, 0x20, 0x30, 0xbd, 0x00, 0x20, 0x30, 0xbd, 0x70, 0xb5, 0x04, 0x46, 0x80, 0x78, 0x0d, 0x46, 0xc0, 0x43, 0x80, 0x07, 0x03, 0xd1, 0x20, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x190d08dc, bytes: &[0x01, 0x20, 0x47, 0xf7, 0x0b, 0xfa, 0x08, 0xb1, 0x01, 0x20, 0x70, 0xbd, 0x60, 0x7a, 0x20, 0xf0, 0x01, 0x00, 0x60, 0x72, 0x28, 0x46, 0x50, 0xf7, 0x72, 0xfc, 0x00, 0x20, 0x70, 0xbd, 0x2d, 0xe9, 0xf0, 0x41, 0x00, 0x26, 0x35, 0x46, 0x28, 0x46, 0x3f, 0xf7, 0x31, 0xfa, 0x04, 0x00, 0x0a, 0xd0, 0x04, 0xf1, 0x0c, 0x00, 0xab, 0xf7, 0xac, 0xf8, 0x07, 0x46, 0x04, 0xf1, 0x08, 0x00, 0xab, 0xf7, 0xa7, 0xf8, 0x38, 0x44, 0x06, 0x44, 0x6d, 0x1c, 0xed, 0xb2, 0x0d, 0x2d, 0xeb, 0xd3, 0x30, 0x46, 0xbd, 0xe8, 0xf0, 0x81, 0x10, 0xb5, 0xff, 0xf7, 0xe2, 0xff, 0x04, 0x46, 0x20, 0x20, 0x47, 0xf7, 0xdd, 0xf9, 0x08, 0xb1, 0x0a, 0x2c, 0x09, 0xd9, 0x05, 0x4c, 0xe0, 0x7a, 0x3f, 0xf7, 0x43, 0xf9, 0x3f, 0xf7, 0x6e, 0xf9, 0xff, 0x20, 0xe0, 0x72, 0x00, 0x20, 0x10, 0xbd, 0x01, 0x20, 0x10, 0xbd, 0xb8, 0x56, 0x20, 0x00, 0x06, 0x49, 0x4b, 0x68, 0x1a, 0x7b, 0x51, 0x08, 0x7f, 0x29, 0x02, 0xd1, 0x59, 0x7b, 0x41, 0xf0, 0x80, 0x01, 0x02, 0xf0, 0x01, 0x02, 0x24, 0x23, 0x56, 0xf7, 0xc9, 0xb9, 0xb8, 0x58, 0x20, 0x00, 0x7f, 0xb5, 0x06, 0x46, 0x01, 0x46, 0x00, 0x20, 0x8d, 0xf7, 0x15, 0xf8, 0x0d, 0x4d, 0x04, 0x46, 0x95, 0xf9, 0x00, 0x00, 0x03, 0x28, 0x11, 0xdc, 0x0b, 0x48, 0x08, 0x21, 0x80, 0x6a, 0x01, 0xeb, 0x80, 0x00, 0x47, 0xf7, 0xa9, 0xf9, 0x48, 0xb1, 0x28, 0x78, 0x40, 0x1c, 0x28, 0x70, 0x0c, 0x20, 0xad, 0xf8, 0x00, 0x00, 0x68, 0x46, 0x01, 0x96, 0x55, 0xf7, 0xa6, 0xfd, 0x94, 0xf9, 0x20, 0x00, 0x04, 0xb0, 0x70, 0xbd, 0xf0, 0x2f, 0x20, 0x00, 0x60, 0x58, 0x20, 0x00, 0x10, 0xb5, 0x14, 0x46, 0x0c, 0x30, 0x31, 0xf7, 0x9e, 0xfa, 0x4f, 0xf4] },
            DataEntry { address: 0x190d09d8, bytes: &[0x46, 0x10, 0xd0, 0xf8, 0x04, 0x03, 0x4f, 0xf4, 0xc0, 0x01, 0xc1, 0xf8, 0x0c, 0x01, 0x00, 0x20, 0x60, 0x71, 0x10, 0xbd, 0x70, 0xb5, 0x05, 0x46, 0x00, 0x24, 0x38, 0xf7, 0xed, 0xfa, 0x00, 0xb1, 0x80, 0x24, 0x44, 0xea, 0x05, 0x00, 0xbd, 0xe8, 0x70, 0x40, 0x00, 0xf0, 0xf7, 0xb8, 0x2d, 0xe9, 0xf0, 0x5f, 0xb0, 0xf8, 0x0d, 0x40, 0x4f, 0xf0, 0x00, 0x0a, 0x06, 0x7b, 0xc7, 0x7b, 0x15, 0x46, 0x04, 0xf0, 0x01, 0x09, 0xc4, 0xf3, 0x00, 0x2b, 0x51, 0x46, 0x50, 0x46, 0x4f, 0xf4, 0x00, 0x73, 0x03, 0xfa, 0x00, 0xf2, 0x98, 0x46, 0x22, 0x42, 0x01, 0xd0, 0x49, 0x1c, 0xc9, 0xb2, 0x40, 0x1c, 0xc0, 0xb2, 0x05, 0x28, 0xf4, 0xd3, 0x2c, 0x81, 0xae, 0x71, 0xef, 0x71, 0xa0, 0x07, 0x01, 0xd5, 0x60, 0x07, 0x08, 0xd4, 0xe0, 0x05, 0x01, 0xd5, 0xe0, 0x07, 0x04, 0xd0, 0x29, 0xb1, 0xe0, 0x05, 0x01, 0xd5, 0x01, 0x29, 0x01, 0xd9, 0x12, 0x20, 0x4e, 0xe0, 0x30, 0x06, 0x01, 0xd4, 0x05, 0x2e, 0x01, 0xd9, 0x11, 0x20, 0x48, 0xe0, 0x04, 0x2e, 0x01, 0xd2, 0x5c, 0x48, 0x01, 0xe0, 0x5b, 0x48, 0x00, 0x1d, 0xb1, 0x07, 0x02, 0x68, 0xc9, 0x0e, 0xff, 0x23, 0x8b, 0x40, 0x9a, 0x43, 0xe3, 0xb2, 0x8b, 0x40, 0x13, 0x43, 0x03, 0x60, 0x4f, 0xf4, 0x48, 0x10, 0x50, 0xf8, 0x88, 0x1f, 0xb3, 0x00, 0x0f, 0x22, 0x9a, 0x40, 0x91, 0x43, 0x01, 0x60, 0x89, 0xf0, 0x01, 0x02, 0x00, 0x21, 0x30, 0x46, 0x38, 0xf7, 0xa8, 0xfa, 0xb9, 0xf1, 0x00, 0x0f, 0x20, 0xd0, 0x30, 0x46, 0x38, 0xf7, 0x8c, 0xfa, 0xc7, 0xb2, 0xbb, 0xf1, 0x00, 0x0f, 0x14, 0xd0, 0x00, 0x20, 0x42, 0x46, 0x02, 0xfa, 0x00, 0xf1, 0x21, 0x42, 0x01, 0xd0, 0x82, 0x46, 0x03, 0xe0, 0x40, 0x1c, 0xc0, 0x00] },
            DataEntry { address: 0x190d0ad0, bytes: &[0x01, 0x00, 0x00, 0xb2, 0x05, 0x28, 0xf5, 0xd3, 0x51, 0x46, 0x30, 0x46, 0x38, 0xf7, 0xe2, 0xf9, 0xaf, 0xf2, 0xf7, 0x01, 0x30, 0x46, 0x38, 0xf7, 0x33, 0xfa, 0x59, 0x46, 0x30, 0x46, 0x38, 0xf7, 0x33, 0xfa, 0x03, 0xe0, 0x39, 0x46, 0x30, 0x46, 0x38, 0xf7, 0x5c, 0xfa, 0xef, 0x71, 0x00, 0x20, 0x68, 0x71, 0xbd, 0xe8, 0xf0, 0x9f, 0x70, 0xb5, 0x00, 0xf1, 0x09, 0x05, 0x00, 0x7b, 0x14, 0x46, 0xc1, 0x08, 0x02, 0xd0, 0x30, 0x20, 0x50, 0x71, 0x70, 0xbd, 0x38, 0xf7, 0x59, 0xfa, 0xe0, 0x71, 0xe8, 0x78, 0xa0, 0x71, 0x00, 0x20, 0x60, 0x71, 0x70, 0xbd, 0x10, 0xb5, 0x14, 0x46, 0x00, 0xf1, 0x0c, 0x01, 0x35, 0x22, 0x2c, 0x48, 0xb1, 0xf7, 0x1a, 0xfa, 0x2b, 0x49, 0x48, 0x79, 0x6f, 0xea, 0x50, 0x12, 0x2a, 0x48, 0x43, 0x78, 0x62, 0xf3, 0x04, 0x13, 0x43, 0x70, 0x08, 0x68, 0x4d, 0x28, 0x01, 0xd9, 0x30, 0x20, 0x20, 0x70, 0x0a, 0x68, 0x25, 0x48, 0x27, 0x3a, 0x08, 0x2a, 0x0d, 0xd2, 0xdf, 0xe8, 0x02, 0xf0, 0x04, 0x08, 0x27, 0x2b, 0x2f, 0x33, 0x37, 0x3b, 0x02, 0x68, 0x42, 0xf4, 0x00, 0x52, 0x02, 0xe0, 0x02, 0x68, 0x22, 0xf4, 0x00, 0x52, 0x02, 0x60, 0x08, 0x79, 0x40, 0x06, 0x2f, 0xd5, 0x08, 0x89, 0x7c, 0xf7, 0x9f, 0xff, 0x04, 0x00, 0x2a, 0xd0, 0x01, 0x20, 0x7b, 0xf7, 0x6c, 0xf9, 0x00, 0x28, 0x25, 0xd0, 0x94, 0xf8, 0xe2, 0x10, 0x41, 0x73, 0x01, 0x21, 0x01, 0x73, 0xee, 0x21, 0x01, 0x75, 0x00, 0x21, 0x41, 0x60, 0x81, 0x60, 0xbd, 0xe8, 0x10, 0x40, 0xa0, 0xf7, 0x48, 0xbf, 0x02, 0x68, 0x42, 0xf4, 0x80, 0x42, 0xdf, 0xe7, 0x02, 0x68, 0x22, 0xf4, 0x80, 0x42, 0xdb, 0xe7, 0x02, 0x68, 0x42, 0xf4, 0x80, 0x52, 0xd7, 0xe7, 0x02, 0x68, 0x22, 0xf4, 0x00, 0x00] },
            DataEntry { address: 0x190d0bcc, bytes: &[0x01, 0x00, 0x80, 0x52, 0xd3, 0xe7, 0x02, 0x68, 0x42, 0xf0, 0x10, 0x02, 0xcf, 0xe7, 0x02, 0x68, 0x22, 0xf0, 0x10, 0x02, 0xcb, 0xe7, 0x10, 0xbd, 0x68, 0x00, 0x32, 0x00, 0x8c, 0x9c, 0x20, 0x00, 0xd9, 0x25, 0x20, 0x00, 0xfc, 0x2f, 0x20, 0x00, 0x10, 0xb5, 0x04, 0x46, 0x02, 0x22, 0xff, 0x21, 0x04, 0x20, 0x70, 0xf7, 0xf1, 0xfa, 0x8b, 0x22, 0x82, 0x72, 0xc4, 0x72, 0xbd, 0xe8, 0x10, 0x40, 0x70, 0xf7, 0x21, 0xb9, 0x0b, 0x4a, 0x12, 0x68, 0x02, 0xf0, 0x03, 0x03, 0x11, 0xb1, 0x1f, 0x21, 0x0a, 0x46, 0x01, 0xe0, 0x7f, 0x21, 0xff, 0x22, 0x1f, 0x28, 0x00, 0xd9, 0x2b, 0xb1, 0x88, 0x42, 0x01, 0xd9, 0x03, 0x2b, 0x01, 0xd3, 0x90, 0x42, 0x01, 0xd9, 0x01, 0x20, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x00, 0x00, 0x14, 0x87, 0x31, 0x00, 0x10, 0xb5, 0x1b, 0x48, 0x33, 0xf7, 0x14, 0xfd, 0xb5, 0xf7, 0x84, 0xf9, 0x00, 0x28, 0x24, 0xd1, 0x18, 0x48, 0x00, 0x78, 0x00, 0x28, 0x20, 0xd0, 0x33, 0xf7, 0xc7, 0xfc, 0x04, 0x46, 0x16, 0x48, 0x00, 0x78, 0x3a, 0xf7, 0x19, 0xf9, 0x10, 0xb1, 0x01, 0x28, 0x07, 0xd0, 0x01, 0xe0, 0x3a, 0xf7, 0x4d, 0xfb, 0x20, 0x46, 0xbd, 0xe8, 0x10, 0x40, 0x33, 0xf7, 0xbb, 0xbc, 0x01, 0x22, 0x00, 0x23, 0x11, 0x46, 0x0e, 0x48, 0x46, 0xf7, 0xb4, 0xfb, 0x20, 0x46, 0x33, 0xf7, 0xb2, 0xfc, 0x33, 0xf7, 0xa9, 0xfc, 0x18, 0xb1, 0x0a, 0x49, 0x01, 0x20, 0x08, 0x60, 0x10, 0xbd, 0x01, 0x22, 0xbd, 0xe8, 0x10, 0x40, 0x4f, 0xf0, 0xff, 0x33, 0x11, 0x46, 0x04, 0x48, 0x46, 0xf7, 0xa1, 0xbb, 0x00, 0x00, 0x98, 0x42, 0x20, 0x00, 0xab, 0x26, 0x20, 0x00, 0xb9, 0x22, 0x20, 0x00, 0x74, 0x42, 0x20, 0x00, 0xc8, 0x22, 0x20, 0x00, 0x2a, 0x00, 0x00, 0x00] },
            DataEntry { address: 0x190d0cc8, bytes: &[0x01, 0x21, 0x01, 0x48, 0x46, 0xf7, 0x66, 0xb9, 0x04, 0x01, 0x60, 0x00] },
            DataEntry { address: 0x192038d4, bytes: &[0x00, 0xe0, 0x21, 0x00] },
            DataEntry { address: 0x19204164, bytes: &[0xed, 0xf7, 0x05, 0x00] },
        ];
        for data_entry in bluetooth_firmware_lines {
            self.bus.bp_write(data_entry.address, data_entry.bytes).await;
        }
    }

    pub(crate) async fn init_wifi(&mut self) {
        while self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR).await & 0x80 == 0 {}

        // "Set up the interrupt mask and enable interrupts"
        // self.bus.bp_write32(CHIP.sdiod_core_base_address + 0x24, 0xF0).await;

        self.bus
            .write16(FUNC_BUS, REG_BUS_INTERRUPT_ENABLE, IRQ_F2_PACKET_AVAILABLE)
            .await;

        // "Lower F2 Watermark to avoid DMA Hang in F2 when SD Clock is stopped."
        // Sounds scary...
        self.bus
            .write8(FUNC_BACKPLANE, REG_BACKPLANE_FUNCTION2_WATERMARK, 32)
            .await;

        // wait for wifi startup
        debug!("waiting for wifi init...");
        while self.bus.read32(FUNC_BUS, REG_BUS_STATUS).await & STATUS_F2_RX_READY == 0 {}

        // Some random configs related to sleep.
        // These aren't needed if we don't want to sleep the bus.
        // TODO do we need to sleep the bus to read the irq line, due to
        // being on the same pin as MOSI/MISO?

        /*
        let mut val = self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_WAKEUP_CTRL).await;
        val |= 0x02; // WAKE_TILL_HT_AVAIL
        self.bus.write8(FUNC_BACKPLANE, REG_BACKPLANE_WAKEUP_CTRL, val).await;
        self.bus.write8(FUNC_BUS, 0xF0, 0x08).await; // SDIOD_CCCR_BRCM_CARDCAP.CMD_NODEC = 1
        self.bus.write8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR, 0x02).await; // SBSDIO_FORCE_HT

        let mut val = self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_SLEEP_CSR).await;
        val |= 0x01; // SBSDIO_SLPCSR_KEEP_SDIO_ON
        self.bus.write8(FUNC_BACKPLANE, REG_BACKPLANE_SLEEP_CSR, val).await;
         */

        // clear pulls
        self.bus.write8(FUNC_BACKPLANE, REG_BACKPLANE_PULL_UP, 0).await;
        let _ = self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_PULL_UP).await;

        // start HT clock
        //self.bus.write8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR, 0x10).await;
        //debug!("waiting for HT clock...");
        //while self.bus.read8(FUNC_BACKPLANE, REG_BACKPLANE_CHIP_CLOCK_CSR).await & 0x80 == 0 {}
        //debug!("clock ok");

        #[cfg(feature = "firmware-logs")]
        self.log_init().await;

        debug!("wifi init done");
    }

    #[cfg(feature = "firmware-logs")]
    async fn log_init(&mut self) {
        // Initialize shared memory for logging.

        let addr = CHIP.atcm_ram_base_address + CHIP.chip_ram_size - 4 - CHIP.socram_srmem_size;
        let shared_addr = self.bus.bp_read32(addr).await;
        debug!("shared_addr {:08x}", shared_addr);

        let mut shared = [0; SharedMemData::SIZE];
        self.bus.bp_read(shared_addr, &mut shared).await;
        let shared = SharedMemData::from_bytes(&shared);

        self.log.addr = shared.console_addr + 8;
    }

    #[cfg(feature = "firmware-logs")]
    async fn log_read(&mut self) {
        // Read log struct
        let mut log = [0; SharedMemLog::SIZE];
        self.bus.bp_read(self.log.addr, &mut log).await;
        let log = SharedMemLog::from_bytes(&log);

        let idx = log.idx as usize;

        // If pointer hasn't moved, no need to do anything.
        if idx == self.log.last_idx {
            return;
        }

        // Read entire buf for now. We could read only what we need, but then we
        // run into annoying alignment issues in `bp_read`.
        let mut buf = [0; 0x400];
        self.bus.bp_read(log.buf, &mut buf).await;

        while self.log.last_idx != idx as usize {
            let b = buf[self.log.last_idx];
            if b == b'\r' || b == b'\n' {
                if self.log.buf_count != 0 {
                    let s = unsafe { core::str::from_utf8_unchecked(&self.log.buf[..self.log.buf_count]) };
                    debug!("LOGS: {}", s);
                    self.log.buf_count = 0;
                }
            } else if self.log.buf_count < self.log.buf.len() {
                self.log.buf[self.log.buf_count] = b;
                self.log.buf_count += 1;
            }

            self.log.last_idx += 1;
            if self.log.last_idx == 0x400 {
                self.log.last_idx = 0;
            }
        }
    }

    pub async fn run(mut self) -> ! {
        let mut buf = [0; 512];
        loop {
            #[cfg(feature = "firmware-logs")]
            self.log_read().await;

            if self.has_credit() {
                let ioctl = self.ioctl_state.wait_pending();
                let tx = self.ch.tx_buf();
                let ev = self.bus.wait_for_event();

                match select3(ioctl, tx, ev).await {
                    Either3::First(PendingIoctl {
                        buf: iobuf,
                        kind,
                        cmd,
                        iface,
                    }) => {
                        self.send_ioctl(kind, cmd, iface, unsafe { &*iobuf }).await;
                        self.check_status(&mut buf).await;
                    }
                    Either3::Second(packet) => {
                        trace!("tx pkt {:02x}", Bytes(&packet[..packet.len().min(48)]));

                        let mut buf = [0; 512];
                        let buf8 = slice8_mut(&mut buf);

                        // There MUST be 2 bytes of padding between the SDPCM and BDC headers.
                        // And ONLY for data packets!
                        // No idea why, but the firmware will append two zero bytes to the tx'd packets
                        // otherwise. If the packet is exactly 1514 bytes (the max MTU), this makes it
                        // be oversized and get dropped.
                        // WHD adds it here https://github.com/Infineon/wifi-host-driver/blob/c04fcbb6b0d049304f376cf483fd7b1b570c8cd5/WiFi_Host_Driver/src/include/whd_sdpcm.h#L90
                        // and adds it to the header size her https://github.com/Infineon/wifi-host-driver/blob/c04fcbb6b0d049304f376cf483fd7b1b570c8cd5/WiFi_Host_Driver/src/whd_sdpcm.c#L597
                        // ¯\_(ツ)_/¯
                        const PADDING_SIZE: usize = 2;
                        let total_len = SdpcmHeader::SIZE + PADDING_SIZE + BdcHeader::SIZE + packet.len();

                        let seq = self.sdpcm_seq;
                        self.sdpcm_seq = self.sdpcm_seq.wrapping_add(1);

                        let sdpcm_header = SdpcmHeader {
                            len: total_len as u16, // TODO does this len need to be rounded up to u32?
                            len_inv: !total_len as u16,
                            sequence: seq,
                            channel_and_flags: CHANNEL_TYPE_DATA,
                            next_length: 0,
                            header_length: (SdpcmHeader::SIZE + PADDING_SIZE) as _,
                            wireless_flow_control: 0,
                            bus_data_credit: 0,
                            reserved: [0, 0],
                        };

                        let bdc_header = BdcHeader {
                            flags: BDC_VERSION << BDC_VERSION_SHIFT,
                            priority: 0,
                            flags2: 0,
                            data_offset: 0,
                        };
                        trace!("tx {:?}", sdpcm_header);
                        trace!("    {:?}", bdc_header);

                        buf8[0..SdpcmHeader::SIZE].copy_from_slice(&sdpcm_header.to_bytes());
                        buf8[SdpcmHeader::SIZE + PADDING_SIZE..][..BdcHeader::SIZE]
                            .copy_from_slice(&bdc_header.to_bytes());
                        buf8[SdpcmHeader::SIZE + PADDING_SIZE + BdcHeader::SIZE..][..packet.len()]
                            .copy_from_slice(packet);

                        let total_len = (total_len + 3) & !3; // round up to 4byte

                        trace!("    {:02x}", Bytes(&buf8[..total_len.min(48)]));

                        self.bus.wlan_write(&buf[..(total_len / 4)]).await;
                        self.ch.tx_done();
                        self.check_status(&mut buf).await;
                    }
                    Either3::Third(()) => {
                        self.handle_irq(&mut buf).await;
                    }
                }
            } else {
                warn!("TX stalled");
                self.bus.wait_for_event().await;
                self.handle_irq(&mut buf).await;
            }
        }
    }

    /// Wait for IRQ on F2 packet available
    async fn handle_irq(&mut self, buf: &mut [u32; 512]) {
        // Receive stuff
        let irq = self.bus.read16(FUNC_BUS, REG_BUS_INTERRUPT).await;
        trace!("irq{}", FormatInterrupt(irq));

        if irq & IRQ_F2_PACKET_AVAILABLE != 0 {
            self.check_status(buf).await;
        }

        if irq & IRQ_DATA_UNAVAILABLE != 0 {
            // TODO what should we do here?
            warn!("IRQ DATA_UNAVAILABLE, clearing...");
            self.bus.write16(FUNC_BUS, REG_BUS_INTERRUPT, 1).await;
        }
    }

    /// Handle F2 events while status register is set
    async fn check_status(&mut self, buf: &mut [u32; 512]) {
        loop {
            let status = self.bus.status();
            trace!("check status{}", FormatStatus(status));

            if status & STATUS_F2_PKT_AVAILABLE != 0 {
                let len = (status & STATUS_F2_PKT_LEN_MASK) >> STATUS_F2_PKT_LEN_SHIFT;
                self.bus.wlan_read(buf, len).await;
                trace!("rx {:02x}", Bytes(&slice8_mut(buf)[..(len as usize).min(48)]));
                self.rx(&mut slice8_mut(buf)[..len as usize]);
            } else {
                break;
            }
        }
    }

    fn rx(&mut self, packet: &mut [u8]) {
        let Some((sdpcm_header, payload)) = SdpcmHeader::parse(packet) else {
            return;
        };

        self.update_credit(&sdpcm_header);

        let channel = sdpcm_header.channel_and_flags & 0x0f;

        match channel {
            CHANNEL_TYPE_CONTROL => {
                let Some((cdc_header, response)) = CdcHeader::parse(payload) else {
                    return;
                };
                trace!("    {:?}", cdc_header);

                if cdc_header.id == self.ioctl_id {
                    if cdc_header.status != 0 {
                        // TODO: propagate error instead
                        panic!("IOCTL error {}", cdc_header.status as i32);
                    }

                    self.ioctl_state.ioctl_done(response);
                }
            }
            CHANNEL_TYPE_EVENT => {
                let Some((_, bdc_packet)) = BdcHeader::parse(payload) else {
                    warn!("BDC event, incomplete header");
                    return;
                };

                let Some((event_packet, evt_data)) = EventPacket::parse(bdc_packet) else {
                    warn!("BDC event, incomplete data");
                    return;
                };

                const ETH_P_LINK_CTL: u16 = 0x886c; // HPNA, wlan link local tunnel, according to linux if_ether.h
                if event_packet.eth.ether_type != ETH_P_LINK_CTL {
                    warn!(
                        "unexpected ethernet type 0x{:04x}, expected Broadcom ether type 0x{:04x}",
                        event_packet.eth.ether_type, ETH_P_LINK_CTL
                    );
                    return;
                }
                const BROADCOM_OUI: &[u8] = &[0x00, 0x10, 0x18];
                if event_packet.hdr.oui != BROADCOM_OUI {
                    warn!(
                        "unexpected ethernet OUI {:02x}, expected Broadcom OUI {:02x}",
                        Bytes(&event_packet.hdr.oui),
                        Bytes(BROADCOM_OUI)
                    );
                    return;
                }
                const BCMILCP_SUBTYPE_VENDOR_LONG: u16 = 32769;
                if event_packet.hdr.subtype != BCMILCP_SUBTYPE_VENDOR_LONG {
                    warn!("unexpected subtype {}", event_packet.hdr.subtype);
                    return;
                }

                const BCMILCP_BCM_SUBTYPE_EVENT: u16 = 1;
                if event_packet.hdr.user_subtype != BCMILCP_BCM_SUBTYPE_EVENT {
                    warn!("unexpected user_subtype {}", event_packet.hdr.subtype);
                    return;
                }

                let evt_type = events::Event::from(event_packet.msg.event_type as u8);
                debug!(
                    "=== EVENT {:?}: {:?} {:02x}",
                    evt_type,
                    event_packet.msg,
                    Bytes(evt_data)
                );

                if self.events.mask.is_enabled(evt_type) {
                    let status = event_packet.msg.status;
                    let event_payload = match evt_type {
                        Event::ESCAN_RESULT if status == EStatus::PARTIAL => {
                            let Some((_, bss_info)) = ScanResults::parse(evt_data) else {
                                return;
                            };
                            let Some(bss_info) = BssInfo::parse(bss_info) else {
                                return;
                            };
                            events::Payload::BssInfo(*bss_info)
                        }
                        Event::ESCAN_RESULT => events::Payload::None,
                        _ => events::Payload::None,
                    };

                    // this intentionally uses the non-blocking publish immediate
                    // publish() is a deadlock risk in the current design as awaiting here prevents ioctls
                    // The `Runner` always yields when accessing the device, so consumers always have a chance to receive the event
                    // (if they are actively awaiting the queue)
                    self.events.queue.publish_immediate(events::Message::new(
                        Status {
                            event_type: evt_type,
                            status,
                        },
                        event_payload,
                    ));
                }
            }
            CHANNEL_TYPE_DATA => {
                let Some((_, packet)) = BdcHeader::parse(payload) else {
                    return;
                };
                trace!("rx pkt {:02x}", Bytes(&packet[..packet.len().min(48)]));

                match self.ch.try_rx_buf() {
                    Some(buf) => {
                        buf[..packet.len()].copy_from_slice(packet);
                        self.ch.rx_done(packet.len())
                    }
                    None => warn!("failed to push rxd packet to the channel."),
                }
            }
            _ => {}
        }
    }

    fn update_credit(&mut self, sdpcm_header: &SdpcmHeader) {
        if sdpcm_header.channel_and_flags & 0xf < 3 {
            let mut sdpcm_seq_max = sdpcm_header.bus_data_credit;
            if sdpcm_seq_max.wrapping_sub(self.sdpcm_seq) > 0x40 {
                sdpcm_seq_max = self.sdpcm_seq + 2;
            }
            self.sdpcm_seq_max = sdpcm_seq_max;
        }
    }

    fn has_credit(&self) -> bool {
        self.sdpcm_seq != self.sdpcm_seq_max && self.sdpcm_seq_max.wrapping_sub(self.sdpcm_seq) & 0x80 == 0
    }

    async fn send_ioctl(&mut self, kind: IoctlType, cmd: u32, iface: u32, data: &[u8]) {
        let mut buf = [0; 512];
        let buf8 = slice8_mut(&mut buf);

        let total_len = SdpcmHeader::SIZE + CdcHeader::SIZE + data.len();

        let sdpcm_seq = self.sdpcm_seq;
        self.sdpcm_seq = self.sdpcm_seq.wrapping_add(1);
        self.ioctl_id = self.ioctl_id.wrapping_add(1);

        let sdpcm_header = SdpcmHeader {
            len: total_len as u16, // TODO does this len need to be rounded up to u32?
            len_inv: !total_len as u16,
            sequence: sdpcm_seq,
            channel_and_flags: CHANNEL_TYPE_CONTROL,
            next_length: 0,
            header_length: SdpcmHeader::SIZE as _,
            wireless_flow_control: 0,
            bus_data_credit: 0,
            reserved: [0, 0],
        };

        let cdc_header = CdcHeader {
            cmd: cmd,
            len: data.len() as _,
            flags: kind as u16 | (iface as u16) << 12,
            id: self.ioctl_id,
            status: 0,
        };
        trace!("tx {:?}", sdpcm_header);
        trace!("    {:?}", cdc_header);

        buf8[0..SdpcmHeader::SIZE].copy_from_slice(&sdpcm_header.to_bytes());
        buf8[SdpcmHeader::SIZE..][..CdcHeader::SIZE].copy_from_slice(&cdc_header.to_bytes());
        buf8[SdpcmHeader::SIZE + CdcHeader::SIZE..][..data.len()].copy_from_slice(data);

        let total_len = (total_len + 3) & !3; // round up to 4byte

        trace!("    {:02x}", Bytes(&buf8[..total_len.min(48)]));

        self.bus.wlan_write(&buf[..total_len / 4]).await;
    }

    async fn core_disable(&mut self, core: Core) {
        let base = core.base_addr();

        // Dummy read?
        let _ = self.bus.bp_read8(base + AI_RESETCTRL_OFFSET).await;

        // Check it isn't already reset
        let r = self.bus.bp_read8(base + AI_RESETCTRL_OFFSET).await;
        if r & AI_RESETCTRL_BIT_RESET != 0 {
            return;
        }

        self.bus.bp_write8(base + AI_IOCTRL_OFFSET, 0).await;
        let _ = self.bus.bp_read8(base + AI_IOCTRL_OFFSET).await;

        block_for(Duration::from_millis(1));

        self.bus
            .bp_write8(base + AI_RESETCTRL_OFFSET, AI_RESETCTRL_BIT_RESET)
            .await;
        let _ = self.bus.bp_read8(base + AI_RESETCTRL_OFFSET).await;
    }

    async fn core_reset(&mut self, core: Core) {
        self.core_disable(core).await;

        let base = core.base_addr();
        self.bus
            .bp_write8(base + AI_IOCTRL_OFFSET, AI_IOCTRL_BIT_FGC | AI_IOCTRL_BIT_CLOCK_EN)
            .await;
        let _ = self.bus.bp_read8(base + AI_IOCTRL_OFFSET).await;

        self.bus.bp_write8(base + AI_RESETCTRL_OFFSET, 0).await;

        Timer::after(Duration::from_millis(1)).await;

        self.bus
            .bp_write8(base + AI_IOCTRL_OFFSET, AI_IOCTRL_BIT_CLOCK_EN)
            .await;
        let _ = self.bus.bp_read8(base + AI_IOCTRL_OFFSET).await;

        Timer::after(Duration::from_millis(1)).await;
    }

    async fn core_is_up(&mut self, core: Core) -> bool {
        let base = core.base_addr();

        let io = self.bus.bp_read8(base + AI_IOCTRL_OFFSET).await;
        if io & (AI_IOCTRL_BIT_FGC | AI_IOCTRL_BIT_CLOCK_EN) != AI_IOCTRL_BIT_CLOCK_EN {
            debug!("core_is_up: returning false due to bad ioctrl {:02x}", io);
            return false;
        }

        let r = self.bus.bp_read8(base + AI_RESETCTRL_OFFSET).await;
        if r & (AI_RESETCTRL_BIT_RESET) != 0 {
            debug!("core_is_up: returning false due to bad resetctrl {:02x}", r);
            return false;
        }

        true
    }
}
