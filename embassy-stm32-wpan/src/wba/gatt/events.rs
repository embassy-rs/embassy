//! GATT Event types and handling
//!
//! This module defines events generated by GATT operations such as
//! characteristic writes, notification confirmations, and MTU exchanges.

use crate::wba::hci::types::Handle;

/// GATT events generated by remote device operations
#[derive(Debug, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GattEvent {
    /// A characteristic attribute was modified by the remote device
    ///
    /// This event is generated when:
    /// - A client writes to a characteristic
    /// - A client writes to the CCCD (Client Characteristic Configuration Descriptor)
    AttributeModified {
        /// Connection handle
        conn_handle: Handle,
        /// Attribute handle that was modified
        attr_handle: u16,
        /// Offset within the attribute value
        offset: u16,
        /// The written data
        data: heapless::Vec<u8, 247>,
    },

    /// Notification was sent successfully
    NotificationComplete {
        /// Connection handle
        conn_handle: Handle,
        /// Attribute handle
        attr_handle: u16,
    },

    /// Indication was confirmed by the client
    IndicationComplete {
        /// Connection handle
        conn_handle: Handle,
        /// Attribute handle
        attr_handle: u16,
    },

    /// MTU exchange completed
    MtuExchangeComplete {
        /// Connection handle
        conn_handle: Handle,
        /// Server MTU
        server_mtu: u16,
    },

    /// GATT procedure completed
    ProcedureComplete {
        /// Connection handle
        conn_handle: Handle,
        /// Error code (0 = success)
        error_code: u8,
    },

    /// GATT procedure timed out
    ProcedureTimeout {
        /// Connection handle
        conn_handle: Handle,
    },

    /// Write request confirmation needed
    ///
    /// Generated for writes that require confirmation (Write Request vs Write Command)
    WritePermitRequest {
        /// Connection handle
        conn_handle: Handle,
        /// Attribute handle
        attr_handle: u16,
        /// Offset within the attribute
        offset: u16,
        /// Data to be written
        data: heapless::Vec<u8, 247>,
    },

    /// Read request (for dynamic value generation)
    ReadPermitRequest {
        /// Connection handle
        conn_handle: Handle,
        /// Attribute handle
        attr_handle: u16,
        /// Offset for read
        offset: u16,
    },

    /// TX buffer available for more data
    TxPoolAvailable {
        /// Connection handle
        conn_handle: Handle,
        /// Number of available buffers
        available_buffers: u16,
    },
}

/// ACI GATT event codes (vendor-specific events)
pub mod aci_event_code {
    /// Attribute was modified by remote device
    pub const GATT_ATTRIBUTE_MODIFIED: u16 = 0x0C01;
    /// GATT procedure completed
    pub const GATT_PROC_COMPLETE: u16 = 0x0C02;
    /// Notification sent
    pub const GATT_NOTIFICATION_COMPLETE: u16 = 0x0C03;
    /// Indication confirmed
    pub const GATT_INDICATION_COMPLETE: u16 = 0x0C04;
    /// ATT MTU exchange response
    pub const ATT_EXCHANGE_MTU_RESP: u16 = 0x0802;
    /// GATT procedure timeout
    pub const GATT_PROC_TIMEOUT: u16 = 0x0C05;
    /// Write permit request
    pub const GATT_WRITE_PERMIT_REQ: u16 = 0x0C06;
    /// Read permit request
    pub const GATT_READ_PERMIT_REQ: u16 = 0x0C07;
    /// TX pool available
    pub const GATT_TX_POOL_AVAILABLE: u16 = 0x0C08;
    /// Server confirmation needed
    pub const GATT_SERVER_CONFIRMATION_NEEDED: u16 = 0x0C09;
    /// Prepare write permit request
    pub const GATT_PREPARE_WRITE_PERMIT_REQ: u16 = 0x0C0A;
}

/// CCCD (Client Characteristic Configuration Descriptor) values
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CccdValue {
    /// Notifications enabled
    pub notifications: bool,
    /// Indications enabled
    pub indications: bool,
}

impl CccdValue {
    /// Create from raw CCCD bytes (little-endian u16)
    pub fn from_bytes(bytes: &[u8]) -> Self {
        if bytes.len() >= 2 {
            let value = u16::from_le_bytes([bytes[0], bytes[1]]);
            Self {
                notifications: (value & 0x0001) != 0,
                indications: (value & 0x0002) != 0,
            }
        } else if bytes.len() == 1 {
            Self {
                notifications: (bytes[0] & 0x01) != 0,
                indications: (bytes[0] & 0x02) != 0,
            }
        } else {
            Self::default()
        }
    }

    /// Convert to raw CCCD bytes
    pub fn to_bytes(&self) -> [u8; 2] {
        let mut value: u16 = 0;
        if self.notifications {
            value |= 0x0001;
        }
        if self.indications {
            value |= 0x0002;
        }
        value.to_le_bytes()
    }
}

/// Offset from characteristic declaration handle to value handle
pub const CHAR_VALUE_HANDLE_OFFSET: u16 = 1;

/// Offset from characteristic declaration handle to CCCD handle
pub const CHAR_CCCD_HANDLE_OFFSET: u16 = 2;

/// Check if an attribute handle is a CCCD based on characteristic handle
pub fn is_cccd_handle(char_handle: u16, attr_handle: u16) -> bool {
    attr_handle == char_handle + CHAR_CCCD_HANDLE_OFFSET
}

/// Check if an attribute handle is a characteristic value based on characteristic handle
pub fn is_value_handle(char_handle: u16, attr_handle: u16) -> bool {
    attr_handle == char_handle + CHAR_VALUE_HANDLE_OFFSET
}
